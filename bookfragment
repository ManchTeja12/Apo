package com.saveetha.interest

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.*
import android.widget.EditText
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import androidx.swiperefreshlayout.widget.SwipeRefreshLayout
import com.saveetha.interest.adapter.BookAdapter
import com.saveetha.interest.models.BookEntry
import com.saveetha.interest.models.SimpleInterestResponse
import com.saveetha.interest.network.ApiClient
import com.saveetha.interest.network.ApiService
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import java.text.SimpleDateFormat
import java.util.*

class BookFragment : Fragment() {

    private lateinit var recyclerView: RecyclerView
    private lateinit var adapter: BookAdapter
    private lateinit var emptyMessage: TextView
    private lateinit var emptyStateLayout: View
    private lateinit var searchEditText: EditText
    private lateinit var progressBar: ProgressBar
    private lateinit var swipeRefreshLayout: SwipeRefreshLayout

    private var originalList: List<BookEntry> = emptyList()
    private lateinit var sharedPreferences: SharedPreferences
    private var currentUserId: String = ""

    private val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
    private val displayDateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())

    companion object {
        private const val EDIT_REQUEST_CODE = 100
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        return inflater.inflate(R.layout.fragment_book, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        initializeUserSession()
        initializeViews(view)
        setupAdapter()
        setupRecyclerView()
        setupSwipeRefresh()
        setupSearchFunctionality()
        loadBookEntries()
    }

    private fun initializeUserSession() {
        sharedPreferences = requireContext().getSharedPreferences("InterestApp", Context.MODE_PRIVATE)
        currentUserId = sharedPreferences.getString("current_user_id", "") ?: ""

        if (currentUserId.isEmpty()) {
            currentUserId = generateNewUserId()
            sharedPreferences.edit().putString("current_user_id", currentUserId).apply()
        }
    }

    private fun generateNewUserId(): String {
        return "user_${System.currentTimeMillis()}_${(1000..9999).random()}"
    }

    private fun initializeViews(view: View) {
        recyclerView = view.findViewById(R.id.recyclerViewBook)
        emptyMessage = view.findViewById(R.id.tvEmptyMessage)
        emptyStateLayout = view.findViewById(R.id.llEmptyState)
        searchEditText = view.findViewById(R.id.etSearch)
        progressBar = view.findViewById(R.id.progressBar)
        swipeRefreshLayout = view.findViewById(R.id.swipeRefreshLayout)
    }

    private fun setupAdapter() {
        adapter = BookAdapter(
            mutableListOf(),
            onEdit = { entry -> editEntry(entry) },
            onDelete = { entry -> deleteEntry(entry) },
            onShare = { entry -> shareEntry(entry) }
        )
    }

    private fun setupRecyclerView() {
        recyclerView.layoutManager = LinearLayoutManager(requireContext())
        recyclerView.adapter = adapter
    }

    private fun setupSwipeRefresh() {
        swipeRefreshLayout.setOnRefreshListener {
            syncWithServer()
        }
    }

    private fun setupSearchFunctionality() {
        searchEditText.addTextChangedListener(object : TextWatcher {
            override fun afterTextChanged(s: Editable?) {
                val searchQuery = s.toString().trim()
                val filteredList = if (searchQuery.isEmpty()) {
                    originalList
                } else {
                    originalList.filter {
                        it.borrowerName.contains(searchQuery, ignoreCase = true) ||
                                it.calculationType.contains(searchQuery, ignoreCase = true)
                    }
                }
                adapter.updateList(filteredList)
                updateEmptyMessageVisibility(filteredList)
            }

            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
        })
    }

    private fun updateEmptyMessageVisibility(list: List<BookEntry>) {
        if (list.isEmpty()) {
            emptyStateLayout.visibility = View.VISIBLE
            recyclerView.visibility = View.GONE
            emptyMessage.text = if (searchEditText.text.toString().trim().isEmpty()) {
                "No saved calculations found.\nCalculate and save to see them here!"
            } else {
                "No entries match your search."
            }
        } else {
            emptyStateLayout.visibility = View.GONE
            recyclerView.visibility = View.VISIBLE
        }
    }

    private fun loadBookEntries() {
        showLoading(true)
        syncWithServer()
    }

    private fun syncWithServer() {
        val apiService = ApiClient.getClient().create(ApiService::class.java)
        val call = apiService.getSimpleInterest(currentUserId)

        call.enqueue(object : Callback<List<SimpleInterestResponse>> {
            override fun onResponse(
                call: Call<List<SimpleInterestResponse>>,
                response: Response<List<SimpleInterestResponse>>
            ) {
                swipeRefreshLayout.isRefreshing = false
                showLoading(false)

                if (response.isSuccessful) {
                    val serverData = response.body() ?: emptyList()
                    originalList = serverData.map { convertServerDataToBookEntry(it) }
                    adapter.updateList(originalList)
                    updateEmptyMessageVisibility(originalList)
                } else {
                    Toast.makeText(requireContext(), "Failed to sync with server", Toast.LENGTH_SHORT).show()
                }
            }

            override fun onFailure(call: Call<List<SimpleInterestResponse>>, t: Throwable) {
                swipeRefreshLayout.isRefreshing = false
                showLoading(false)
                Toast.makeText(requireContext(), "Network error: ${t.message}", Toast.LENGTH_SHORT).show()
            }
        })
    }

    private fun convertServerDataToBookEntry(data: SimpleInterestResponse): BookEntry {
        return BookEntry(
            id = 0L,
            userId = currentUserId,
            borrowerName = "Simple Interest Calculation",
            date = formatDate(data.From_Date),
            receivedDate = formatDate(data.To_Date),
            amount = (data.Total_Amount.toDouble() - data.simple_interest.toDouble()),
            interestRate = data.Interest_Rate.toString(),
            totalTime = data.Time_Period,
            interestAmount = data.simple_interest.toDouble(),
            totalAmount = data.Total_Amount.toDouble(),
            calculationType = "Simple Interest"
        )
    }

    private fun formatDate(dateString: String?): String {
        if (dateString.isNullOrBlank()) return ""
        return try {
            val serverDate = dateFormat.parse(dateString)
            displayDateFormat.format(serverDate ?: Date())
        } catch (e: Exception) {
            dateString
        }
    }

    private fun showLoading(show: Boolean) {
        progressBar.visibility = if (show) View.VISIBLE else View.GONE
    }

    private fun editEntry(entry: BookEntry) {
        val intent = when (entry.calculationType) {
            "Simple Interest" -> Intent(requireContext(), SimpleInterestActivity::class.java)
            "Compound Interest" -> Intent(requireContext(), CompoundInterestActivity::class.java)
            "Home Loan" -> Intent(requireContext(), HomeLoanActivity::class.java)
            "Car Loan" -> Intent(requireContext(), CarLoanActivity::class.java)
            else -> {
                Toast.makeText(requireContext(), "Unsupported type: ${entry.calculationType}", Toast.LENGTH_SHORT).show()
                return
            }
        }

        intent.putExtra("EDIT_MODE", true)
        intent.putExtra("ENTRY_ID", entry.id)
        intent.putExtra("BORROWER_NAME", entry.borrowerName)
        intent.putExtra("AMOUNT", entry.amount)
        intent.putExtra("START_DATE", entry.date)
        intent.putExtra("END_DATE", entry.receivedDate)
        intent.putExtra("INTEREST_RATE", entry.interestRate.toDoubleOrNull() ?: 0.0)
        intent.putExtra("TOTAL_TIME", entry.totalTime)
        intent.putExtra("INTEREST_AMOUNT", entry.interestAmount)
        intent.putExtra("TOTAL_AMOUNT", entry.totalAmount)
        intent.putExtra("CALCULATION_TYPE", entry.calculationType)

        startActivityForResult(intent, EDIT_REQUEST_CODE)
    }

    private fun deleteEntry(entry: BookEntry) {
        androidx.appcompat.app.AlertDialog.Builder(requireContext())
            .setTitle("Delete Entry")
            .setMessage("Are you sure you want to delete '${entry.borrowerName}'?")
            .setPositiveButton("Delete") { _, _ ->
                performDelete(entry)
            }
            .setNegativeButton("Cancel", null)
            .show()
    }

    private fun performDelete(entry: BookEntry) {
        // TODO: Replace with API call to delete
        originalList = originalList.filter { it.id != entry.id }
        adapter.updateList(originalList)
        updateEmptyMessageVisibility(originalList)
        Toast.makeText(requireContext(), "Deleted ${entry.borrowerName}", Toast.LENGTH_SHORT).show()
    }

    private fun shareEntry(entry: BookEntry) {
        val shareText = """
            üìä ${entry.calculationType} Calculation
            
            üë§ Borrower: ${entry.borrowerName}
            üí∞ Principal Amount: ‚Çπ${String.format("%.2f", entry.amount)}
            üìÖ Period: ${entry.date} to ${entry.receivedDate}
            üìà Interest Rate: ${entry.interestRate}%
            ‚è∞ Duration: ${entry.totalTime}
            üíµ Interest Earned: ‚Çπ${String.format("%.2f", entry.interestAmount)}
            üè¶ Total Amount: ‚Çπ${String.format("%.2f", entry.totalAmount)}
            
            Calculated using Interest Calculator App
        """.trimIndent()

        val intent = Intent().apply {
            action = Intent.ACTION_SEND
            putExtra(Intent.EXTRA_TEXT, shareText)
            type = "text/plain"
        }
        startActivity(Intent.createChooser(intent, "Share Calculation"))
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == EDIT_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
            loadBookEntries()
        }
    }
}
